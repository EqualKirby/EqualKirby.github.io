{"categories":[{"title":"LeetCode","uri":"https://equalkirby.github.io/categories/leetcode/"}],"posts":[{"content":"花了好幾天的第三篇\n我好像很久以前就卡這題，但也一直沒把這題放在心上去解，就這樣拖延了好幾年\u0026hellip;\n題目連結 想法 基本上時間複雜度 $\\mathcal{O}(m+n)$ 的方式可以說是顯而易見， 利用 merge 的方式合併兩個陣列，接著根據長度取出中間的元素傳回就好，非常簡單。\n問題主要出在，怎麼樣讓時間複雜度是 $\\mathcal{O}(log(m+n))$ 呢？ 提到中位數，又要對數的時間複雜度，不難聯想應該這題與二分搜有關係， 在此列上四個參考網址，我認為看完以後應該就可以明白怎麼做到的了， 此文就大致上給個想法方向，跟一些細節的提點就可以了。\n關於二分搜的區間跟延伸 這篇的話，我個人覺得前幾個回復都值得一看。 最佳回答主要琢磨於正確性，底下有個回答有介紹全閉跟左閉右開區間寫法的異同， 並且延伸到譬如找到滿足條件的第一個元素或是最後一個元素之類的， 算是幫助複習二分搜的各種寫法與延伸。\nLeetCode 上最多人給好評的解答 此文即是我主要參考的實作。 評論中有一個 More intuitive thinking process 的回覆也很值得一看，補充了一些原文沒有說明得很清楚的細節。\n首先的問題是，到底要怎麼在兩個已經排序的陣列中找到中位數？ 原文給出，其實把中位數想成以下這樣，就可以比較簡單地解決問題：\n dividing a set into two equal length subsets, that one subset is always greater than the other\n 假設現在只有一個陣列，可以想像成要用一根棍子將陣列分成兩邊(棍子只能放在數字與數字間)。\n如果陣列長度是：\n 奇數：那就讓左邊比右邊多一個元素，中位數就是棍子左邊的數字 偶數：就讓兩邊有一樣多的元素，中位數就是棍子左右兩側的數字取平均  這也是說明為何程式碼中的 half_len 裡面會有 +1 的緣故。\narray: 1 2 3 4 5 sitck_place: _ _ _ | _ _ stick_index: 0 1 2 3 4 5  以這個例子來說，陣列裡面有五個數字， 根據上面的規則，我們棍子要放在能讓元素個數是左三右二的狀況。 所有能放棍子的位置(stick_place)已用底線標示出來，並且由左至右編號(stick_index)， 顯然地，棍子擺在3號位置就可以滿足我們的條件。\n 那延伸到兩個陣列的話，其實就是我們要在兩個陣列裡面各找一根棍子， 這兩根棍子要滿足底下的條件：\n  如果兩個陣列的總和長度為：\n 奇數：兩根棍子左側的元素個數要比兩根棍子右側的元素個數多一個元素 偶數：兩根棍子的左右側元素個數要相等    兩根棍子的左側元素，全部要小於等於兩根棍子的右側元素\n 因為兩個陣列都是排序過，所以其實可以看成是兩根棍子各自左邊的元素取較大的那個數，要小於等於兩根棍子各自右邊的元素取較小的那個數    這邊的話，因為原文有例子與數學定義，就不再具體說明。\n 那問題變成要怎麼找兩根棍子的位置呢？\n其實，因為要求棍子左右兩邊的元素個數要相等(或左邊比右邊多一個)。 連帶地，一旦決定一個陣列中棍子的位置以後，就可以確定另一個陣列中棍子要擺哪。\n但，對於較長的陣列並不是每個位置都可以擺棍子的。 譬如說兩個陣列的長度分別為 7 和 1，那麼如果在較長的陣列裡面把棍子擺在最左側， 顯然在較短的陣列裡面，棍子怎麼擺都沒辦法滿足我們上面說的第一個關於長度的條件。\n相對地，較短的陣列裡面每個位置都可以擺棍子， 可以看原文裡面的 ps.2，有簡單說明怎麼證明這件事情。\n 再來，我們就可以在較短的陣列裡面，針對每個可以擺的位置進行二分搜檢查條件是否成立。 至於這邊要怎麼樣檢查邊界條件與進行比較，可以直接參考原文(某些邊界條件會自動隱含其他條件，這部分的推導原文中也有)。\n不過，棍子有可能會因為被擺在最左側或是最右側，導致左側或是右側沒有元素。 但因為原題目有規定 $m+n \\ge 1$，所以兩根棍子的左側必定至少有一個元素，但右側可能沒有任何元素。\n拓展到 kth 的解法 這個解法就是看程式碼會有點不知道在搞甚麼，不過還好內文有舉例跟證明。\n假設現在有兩個陣列 $A, B$，其大小分別為 $5, 3$， 因此我們要取中位數，即是計算第 4 小($k = (5+3) / 2 = 4$)的元素。 做法是去兩個陣列各自檢查其第 2 小($k / 2 = 4 / 2 = 2$)的元素，接著我們有以下兩種 case 討論(zero-based index)：\n  $A[1] \u0026lt; B[1]$ 這表示我們可以捨去 $A$ 的前 $k/2$ 個元素，原因在於，$A[0..k/2], B[0..k/2]$ 至多只有 $k$ 個元素， 當 $B[1]$ 比較大的時候，對於 $A[1]$ 來說，最多只有 $A[0..k/2-1], B[0..k/2-1]$ 這些元素比他小， 而這些元素總共有 $k - 2$ 個，表示 $A[1]$ 最好的狀況就是第 $k - 1$ 小的元素\n  $A[1] \\ge B[1]$ 這個狀況同理可證\n  於是我們就可以把 $k$ 縮小一半，並利用遞迴求解，至於實作和 corner case 可以看 code 理解。 實際上我是在交出二分搜以後，參考了 C++ 執行時間在前段班的解法以後，才發現這種解法比較主流。 查了資料理解正確性的證明以後，我反而比較喜歡這個方法，整體來說其實他比較簡單，而且實作上沒那麼多眉角。\n不用額外分奇偶數的解法 這個其實算是選擇性的資料。\n這篇主要在說，想像在原陣列裡面插入 # 在數字間與前後端，棍子可以擺在數字或是 # 上。 當棍子擺在數字上時，數字會被分成兩個與原數字相同的數字擺在棍子左右兩側，因此就不需要針對奇偶數狀況分開討論。 不過索引的範圍會比原先問題大上兩倍，加上還要計算後才能回去用在原本陣列上，或許不會比較快， 但這種想法說不定在其他問題也用得上，個人建議是可以看一下的。\n時間複雜度 二分搜：顯而易見的 $\\mathcal{O}(log(min(m, n)))$\nkth：顯而易見的 $\\mathcal{O}(log(\\frac{m+n}{2}))$\n空間複雜度 都是顯而易見的 $\\mathcal{O}(1)$\n程式碼 二分搜\nclass Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { const auto m = static_cast\u0026lt;int\u0026gt;(nums1.size()); const auto n = static_cast\u0026lt;int\u0026gt;(nums2.size()); if(m \u0026gt; n) return findMedianSortedArrays(nums2, nums1); // int is sufficient, guaranteed by 0 \u0026lt;= m, n \u0026lt;= 1000 auto first = 0; auto last = m + 1; const auto half_len = (m + n + 1) / 2; while(first \u0026lt; last) { const auto i = first + (last - first) / 2; const auto j = half_len - i; if(i \u0026gt; 0 \u0026amp;\u0026amp; nums1[i - 1] \u0026gt; nums2[j]) { last = i; } else if(i \u0026lt; m \u0026amp;\u0026amp; nums2[j - 1] \u0026gt; nums1[i]) { first = i + 1; } else { const auto l1 = i==0 ? numeric_limits\u0026lt;int\u0026gt;::min() : nums1[i-1]; const auto l2 = j==0 ? numeric_limits\u0026lt;int\u0026gt;::min() : nums2[j-1]; const auto mleft = max(l1, l2); // be careful when m + n = 1 if((m + n) % 2 == 1) return mleft; const auto r1 = i==m ? numeric_limits\u0026lt;int\u0026gt;::max() : nums1[i]; const auto r2 = j==n ? numeric_limits\u0026lt;int\u0026gt;::max() : nums2[j]; const auto rmin = min(r1, r2); return (mleft + rmin) / 2.0; } } return -1; } };  kth\nclass Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { const auto m = nums1.size(); const auto n = nums2.size(); const auto len = m + n; const auto half = (len + 1) / 2; if(len % 2 == 0) return (get_kth(nums1.data(), m, nums2.data(), n, half) + get_kth(nums1.data(), m, nums2.data(), n, half + 1)) / 2.0; else return get_kth(nums1.data(), m, nums2.data(), n, half); } double get_kth(const int* pa, const int m, const int* pb, const int n, int k) { if(m == 0) return pb[k - 1]; else if(n == 0) return pa[k - 1]; else if(k == 1) return min(pa[0], pb[0]); const auto npa = pa + min(k / 2, (int)m) - 1; const auto npb = pb + min(k / 2, (int)n) - 1; if(*npa \u0026lt; *npb) { const auto shrunk_size = npa - pa + 1; return get_kth(npa + 1, m - shrunk_size, pb, n, k - shrunk_size); } else { const auto shrunk_size = npb - pb + 1; return get_kth(pa, m, npb + 1, n - shrunk_size, k - shrunk_size); } } }; ","id":0,"section":"posts","summary":"\u003cp\u003e花了好幾天的第三篇\u003c/p\u003e\n\u003cp\u003e我好像很久以前就卡這題，但也一直沒把這題放在心上去解，就這樣拖延了好幾年\u0026hellip;\u003c/p\u003e","tags":null,"title":"Median of Two Sorted Arrays","uri":"https://equalkirby.github.io/2021/03/median-of-two-sorted-arrays/","year":"2021"},{"content":"刷題第二篇\n題目連結 想法 令輸入的字串為 $Str$，$S_i$ 是從 index $i$ 開始的最長且不重複的子字串\n這樣的話，原先的問題就是求 $max(len(S_0), len(S_1), len(S_2),\\dots, len(S_{len(Str)-1}))$\n假設 $S_i$ 這個子字串就是 $Str[i, j)$，那麼只有可能是兩種情況：\n $j = len(Str)$ $j \\lt len(Str)$ 且 $\\exists k \\in [i, j), Str[k] = Str[j]$\n若否，會與 $S_i $定義矛盾  因此，我們就知道 $S_i$ 怎麼求了：針對每個 $S_i$ 都有個 index 從 $i$ 往後跑一次，檢查到如果有相同的字元就停止，即可得到 $j$\n記錄有沒有相同的字元可以簡單地利用 table，因為題目有說可能出現的字元就是英文、數字和符號，那我就偷懶一點，假設他是 ASCII 囉\n char 是不是 signed 並沒有被規定，更為嚴謹的方式是將其當 index 用之前要先轉到 unsigned\n 但其實再仔細觀察，會發現針對上面說的第二種情況，可以得到：\n$max(len(S_{i+1}), len(S_{i+2}), len(S_{i+3}),\\dots, len(S_k)) \\le len(S_i)$\n要證明也很簡單，上述不等式左側裡面的任一個子字串，其起始 index 皆比 $i$ 大，但右端點(半開區間)都是 index $j$\n因此，其區間必然內嵌於 $[i, j)$ 裡面，長度自然不會超過 $len(S_i)$ (若否，會與 $S_i $定義矛盾)\n那麼，我們就可以跳過 $S_{i+1}, S_{i+2}, S_{i+3},\\dots, S_k$ 的計算，而是直接往下求 $S_{k+1}$\n而且，index $j$ 也不需要往回設定從 $k+1$ 開始，因為上一次的 $S_i$ 保證了 $Str[i, j)$ 裡面沒有重複的字元\n已知 $Str[k] = Str[j]$ 且 $k \\in [i, j)$，$Str[k+1, j]$ 自然不會有重複的字元(不然會矛盾)\n因此，這個問題實際上就可以變成所謂的 sliding window\n利用兩個 pointer 維護子字串的起點 $start$ 與終點 $end$，並確保起點到終點之間是沒有重複的字元\n在過程中持續監視子字串的長度，並且將最大值記錄下來，那就會是答案了\n剩下的問題只剩下怎樣有效率地知道 $k$ 是多少？\n我們可以將前面的 table 從記錄字元出現的有無，變成記錄看到 $end$ 為止，上一次該字元出現的 index\n如果該 index 是大於等於 $start$，那就表示目前檢查的字元與 sliding window 內的字元有所重複\n時間複雜度 可以觀察到 sliding window 有這幾個特性：\n $start \\le end$ $start$ 只會停留或是往右走 $end$ 只會停留或是往右走 任何一次更新，$start$ 和 $end$ 之中一定至少有一個往右走  因此 $start$ 與 $end$ 最多就是各走 n 步，得到 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(1)$\n程式碼 #include\u0026lt;algorithm\u0026gt; class Solution { public: int lengthOfLongestSubstring(string s) { using namespace std; int loc[256]; fill(begin(loc), end(loc), -1); auto start = 0; auto len = 0; for(auto i = 0; i \u0026lt; s.size(); i++) { if(loc[s[i]] \u0026gt;= start) { start = loc[s[i]] + 1; } else { len = max(len, i - start + 1); } loc[s[i]] = i; } return len; } }; ","id":1,"section":"posts","summary":"\u003cp\u003e刷題第二篇\u003c/p\u003e","tags":null,"title":"Longest Substring Without Repeating Characters","uri":"https://equalkirby.github.io/2021/03/longest-substring-without-repeating-characters/","year":"2021"},{"content":"感覺該來開始刷題了\n總之這個是第一篇吧\n題目連結 想法 這題其實蠻簡單的，簡單來說就是用 linked list 進行兩個數字的加法\n預先給的格式其實也已經很貼心的把數字倒序，所以就利用 carry flag 從後面往前加就好\n實作時比較需要注意的幾點：\n 題目有保證兩個傳進來的 pointer 非空，但兩個 linked list 可能不等長 即使兩個 pointer 都跑到 nullptr 了，carry flag還有可能沒跑完 對於第一個要被創出來的 Node 要怎樣寫比較統一  底下的 code 算是盡量比較統一的寫法\n存了一個 dummy node 在 stack 上，實際上要傳回去第一個 node 是 head.next\n實際上我用 seq[] 只是因為我很討厭打一樣的 code 打兩次而已\n因為我沒辦法一次寫過要修修改改，所以有兩個地方出現一樣的 code 我很容易打錯QQ\n時間複雜度 顯而易見的 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(n)$\n程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ #include\u0026lt;algorithm\u0026gt; class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { using namespace std; auto head = ListNode(); auto prev = \u0026amp;head; auto carry = 0; ListNode* seq[] = {l1, l2}; while(any_of(begin(seq), end(seq), [](auto p){return p;}) || carry) { auto sum = carry; for(auto\u0026amp; p : seq) { if(p) { sum += p-\u0026gt;val; p = p-\u0026gt;next; } } carry = sum / 10; auto cur = new ListNode(sum % 10); prev-\u0026gt;next = cur; prev = cur; } return head.next; } }; ","id":2,"section":"posts","summary":"\u003cp\u003e感覺該來開始刷題了\u003cbr\u003e\n總之這個是第一篇吧\u003c/p\u003e","tags":null,"title":"Add Two Numbers","uri":"https://equalkirby.github.io/2021/03/add-two-numbers/","year":"2021"},{"content":"#include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hellow World\u0026quot; \u0026lt;\u0026lt; endl; }  $\\forall x \\in X$\n","id":3,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hellow World\u0026quot; \u0026lt;\u0026lt; endl; }  $\\forall x \\in X$","tags":null,"title":"First Post","uri":"https://equalkirby.github.io/2021/01/first-post/","year":"2021"}],"tags":[]}