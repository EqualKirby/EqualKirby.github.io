{"categories":[{"title":"LeetCode","uri":"https://equalkirby.github.io/categories/leetcode/"}],"posts":[{"content":"水題，但還是有可以注意的點\n題目連結 想法 這題目重點在越界檢查的部分和讀懂題目本身。\n在上一篇有討論了怎麼檢查越界的這件事，這題與上一題不同的地方在於越界以後用該方向的極值做為表示。 譬如超過最大可以表達的正數就用最大值表示，低於最小可以表達的負數就用最小值表示。\n我個人這題的實作就有點隨便，沒有特地把程式碼弄得精巧一點。 原本我想把 abs 替換成 * sign，但跟上一題有相同的狀況，如果 limit 是最小值然後 digit 是 $0$ 的狀況下就會爆開。\n時間複雜度 顯而易見的 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(1)$\n程式碼 class Solution { public: int myAtoi(string s) { auto result = 0; auto sign = 1; auto limit = numeric_limits\u0026lt;int\u0026gt;::max(); auto i = 0; while (i \u0026lt; s.size() \u0026amp;\u0026amp; s[i] == ' ') i++; if (i \u0026lt; s.size() \u0026amp;\u0026amp; (s[i] == '+' || s[i] == '-')) { if (s[i] == '-') { sign = -1; limit = numeric_limits\u0026lt;int\u0026gt;::min(); } i++; } while (i \u0026lt; s.size() \u0026amp;\u0026amp; isdigit(s[i])) { auto digit = (s[i] - '0') * sign; if (abs((limit - digit) / 10) \u0026lt; abs(result)) return limit; result *= 10; result += digit; i++; } return result; } }; ","id":0,"section":"posts","summary":"\u003cp\u003e水題，但還是有可以注意的點\u003c/p\u003e","tags":null,"title":"String to Integer (atoi)","uri":"https://equalkirby.github.io/2021/03/string-to-integer-atoi/","year":"2021"},{"content":"水題，但還是有可以注意的點\n題目連結 想法 這種題目其實不太難，主要重點還是在檢查越界的部分，去查解法會發現這題目很像是照妖鏡。\n主要是因為 C++ 對於這方面的規定實在是太多 implementation-defined 或是 undefined 的行為，所以在寫的時候要注意的眉角很多。 譬如，對於有號數來說，加減導致的 overflow 是 undefined behavior。而有號數確定是 two\u0026rsquo;s complement 也是到 C++20 才確定的。\n底下的實作算是只依賴 numeric_limits\u0026lt;int\u0026gt;::min() 跟 numeric_limits\u0026lt;int\u0026gt;::max() 這兩個常數的寫法，檢查的方法其實就是條件的移項而已。 之所以用了 abs 是因為對於 x 的正負狀況不同，該式有可能是 $\u0026lt;$ 或是 $\u0026gt;$，但我不想分成兩大段程式碼去跑，所以就出此下策。\n最後一個在 LeetCode 測試時發現可以注意的點，那就是我一開始把 abs 放在 (limit - digit)，但這是錯的\u0026hellip;\u0026hellip; 因為在 limit 是 numeric_limits\u0026lt;int\u0026gt;::min()， digit 為 $0$ 的狀況下，abs(limit - digit) 就會超出常見系統的最大值而爆開了。\n 在 two\u0026rsquo;s complement 底下，$abs(min) = max + 1$\n 時間複雜度 顯而易見的 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(1)$\n程式碼 class Solution { public: int reverse(int x) { const auto limit = (x \u0026lt; 0) ? numeric_limits\u0026lt;int\u0026gt;::min() : numeric_limits\u0026lt;int\u0026gt;::max(); auto ans = 0; while (x != 0) { auto digit = x % 10; if (abs((limit - digit) / 10) \u0026lt; abs(ans)) return 0; x /= 10; ans *= 10; ans += digit; } return ans; } }; ","id":1,"section":"posts","summary":"\u003cp\u003e水題，但還是有可以注意的點\u003c/p\u003e","tags":null,"title":"Reverse Integer","uri":"https://equalkirby.github.io/2021/03/reverse-integer/","year":"2021"},{"content":"花了超過一個禮拜的第四篇\n這題我前後大概嘗試了三、四種解法，也有一些收穫想說可以分享一下\n題目連結 想法 這題並不是太難，不要寫出太爛的方法基本上都可以通過。 如果不知道怎麼解的話，我推薦可以直接參考解答裡面的 Approach 4: Expand Around Center， 前面幾種解法我個人認為是來亂的，動態規劃既沒在時間上有優勢，空間複雜度還輸不少，就別浪費腦力去理解了。\n對於這種選定回文中央往左右檢查的方法，需要注意的部分就是：當中央是在兩個字母中間，譬如 abba 的正中心， 索引的處理方式與 aba 並不一樣，可以看到他提供的實作是額外寫一個 expandAroundCenter，並使 left 和 right 分開傳， 藉此在每個索引位置時，各自檢查一次 left = right = i 與 left = i, right = i + 1；前者對應 aba，後者對應 abba 的狀況。\n 插入假想 # 而我在上一篇 Median of Two Sorted Arrays 中，提到有個不分奇偶數的解法，\n簡單來說，為了避免處理像是 abba 這種回文的中心不在字串裡面的狀況，我們可以想像插入一個沒有出現在字串裡面的字元 # 在所有間隙(彷彿數字間能插棍子的位置)， 使其變成 #a#b#b#a#，這樣子當中心點在兩個 b 中間的 # 時，就可以很自然的往左右檢查，不需要有特別處理。\n而且還可以順便觀察一件有趣的事情，譬如這個例子：\nstring: # a # b # a # a # b # a # index: 0 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;--------|--------\u0026gt; a b a len = 6 - 3 = 3 \u0026lt;-----------------|-----------------\u0026gt; a b a a b a len = 12 - 6 = 6  示意性地，我標了裡面的兩個回文，會發現把回文最右端的索引值減去中央的索引值，得到的值會與真正原先的字串長度相同，我們可以把這個距離稱為半徑(半開)。\n另外，實際上我們也不用真的插入 #，雖然丟到網路上查詢還真的不少人會這樣寫，但這其實可以透過索引的計算來完成。\nstring: (# a) (# b) (# a) (# a) (# b) (# a) (# ) extended index : 0 1 2 3 4 5 6 7 8 9 10 11 12 (ext. index) / 2: 0 1 2 3 4 5 6 i j  這邊有兩種狀況：\n  對於索引 $i$ 是指向 字母 時：\n這是對應回文是 aba 時，我們會希望起先檢查回文時，left = right，也就是左邊要拿到這一組括號的字母，右邊也是拿到這組括號的字母。\n  對於索引 $j$ 是指向 # 時：\n這是對應回文是 abaaba 時，我們會希望起先檢查回文時，left + 1 = right，也就是左邊要拿到上一組括號的字母，右邊是拿到這組括號的字母。\n  可以發現，這兩個規則統整下來 left = (index - 1) / 2 和 right = index / 2 可以滿足上述兩個狀況。\n於是我試著寫了一下，結果發現速度好像不是很理想，大概在中間上游一點而已。 我就去看了一下前面跑得不錯快的 sample code，發現其實有個做法不難，跑得又莫名的快。\n 跳過中央重複字元的 Expand Around Center 那就是，不需要將字串想像成有插入 # 的狀況下去算索引，在原本的字串索引上計算即可，那這樣我們要怎麼處理 abba 這種回文呢？\n其實答案很簡單，就是讓 right 指向最右邊的 b 就好，這樣不論中間有奇數個還是偶數個相同字元，最後 left 與 right 都會在對的位置，並藉此各自往左右搜索即可。\n Manacher\u0026rsquo;s Algorithm 最後，其實經過查詢，會發現此題是有時間複雜度為 $\\mathcal{O}(n)$ 的解法，該演算法為 Manacher's Algorithm。 這演算法網路上有不少介紹的資源，我自己沒覺得有哪一篇寫得特別好的，就請大家自己多搜尋一下吧。 簡單來說，回文會有以中心點為鏡像的特性，所以我們可以將前面所有計算過的， 以該字元為中心，最長之回文的半徑存起來，後面的計算是可以重複利用這些結果的。\n 你說如 abba 的中心點在哪？就是利用假想插入 # 這招就好了，不然我也不用浪費這麼多篇幅講解XD\n 假設我們在計算以索引 i 所指向的字元為中心的當下，已記錄了先前所有計算過的回文中， 右端最接近尾端的大回文(這樣才越容易覆蓋到後面要計算的索引)，那可以針對大回文有沒有覆蓋到 i 做討論：\n  如果該大回文沒有覆蓋此字元，表示你能用的資訊用完了，乖乖地從現在的中心往左右找，並將其作為新的大回文，記錄其右端(因為右端一定會比舊的大回文接近尾端，不如就會被覆蓋到)。\nindex: 0 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;-----------|-----------\u0026gt; // large palindrome i ?-----|-----?    如果該大回文覆蓋此字元，那麼有以下幾種狀況：\nCase 1: 鏡像回文在大回文之內(邊界不會相等) index: 0 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;-----------------|-----------------\u0026gt; // large palindrome \u0026lt;-----|-----\u0026gt; i \u0026lt;-----|-----\u0026gt;  此時，我們把 i 對著該回文的中心做鏡像，得到 $3$，而我們知道當在索引 $3$ 的小回文的左端不超過大回文的左端時， 索引 $9$ 的小回文應該與在索引 $3$ 的小回文一模一樣，因此有相同的半徑。 若否，那麼要不索引 $3$ 的小回文不是最長的，要不大回文就不是回文，兩種狀況都會導致矛盾。\nCase 2: 鏡像回文超出大回文 index: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;-----------|-----------\u0026gt; // large palindrome \u0026lt;-----|-----\u0026gt; i \u0026lt;--|--\u0026gt; \u0026lt;--------------|--------------\u0026gt; // If not, the big palindrome should be like this. Contradiction.  此時，我們把 i 對著該回文的中心做鏡像，得到 $5$，而我們知道當在索引 $5$ 的小回文的左端超過大回文的左端時， 索引 $11$ 的小回文右端最多僅到大回文的右端，並不會超過。 若否(超出大回文右端)，表示對 $11$ 往右延伸的字元，會與 $5$ 往左延伸的字元相同，那這樣的話，大回文就不是以該字元為中心的最長回文，導致矛盾。\nCase 3: 鏡像回文邊界剛好切齊大回文邊界 index: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;-----------|-----------\u0026gt; // large palindrome \u0026lt;--|--\u0026gt; i ?------\u0026lt;--|--\u0026gt;------?  此時，我們把 i 對著該回文的中心做鏡像，得到 $5$，而我們知道當在索引 $11$ 的小回文的左端切齊大回文的左端時， 索引 $11$ 的小回文右端至少切齊大回文的右端，但會不會超過是需要檢查的。 為何不會僅僅是切齊而已？以此例來說，這只代表 $str[3] \\ne str[7]$，但這不代表鏡像過去以後，會得到 $str[9] \\ne str[13]$，因為這個資訊並沒有辦法透過大回文得到(已經超出範圍)。 於是，這種狀況我們會從 left = 10 和 right = 12 開始往左右進行檢查，如果檢查出新的回文，其右端自然超過原先大回文的右端，故成為新的大回文。\n   至此，怎麼更新大回文和填入裡面小回文的流程已經大致講完，如果不清楚的部分，我推薦可以參考程式碼。\n如果主要概念不太理解，可以先看 Python 版的，這算是流程蠻好理解的。\n本篇的實作主要參考此 C++ 版的， 這程式真的挺猛的，裡面其實利用很多性質簡化了不少計算，但大概因為沒什麼註解所以乏人問津吧XD 有的不容易看出的性質我有註解在本文最後的程式碼裡，其中那個提早結束的 i \u0026lt; 2 * size - l 真的也是很競程的寫法呢(那是 l 不是 $1$)。\n 推薦閱讀順序是上面的 Python 版，接著是本文附上的程式碼，最後是上面的 C++ 版。\n 時間複雜度 從中央往左右找：顯而易見的 $\\mathcal{O}(n^2)$\nManacher\u0026rsquo;s Algorithm：$\\mathcal{O}(n)$\n 在執行的時候，實際上大回文的右端是單調遞增的，所有迴圈都是用在大回文右端不夠提供資訊的狀況故想辦法把他往右移。\n 空間複雜度 從中央往左右找：顯而易見的 $\\mathcal{O}(1)$\nManacher\u0026rsquo;s Algorithm：$\\mathcal{O}(n)$\n程式碼 從中央往左右檢查，假想插入 # 去計算索引的解法：\nclass Solution { public: string longestPalindrome(string s) { // the pair (len, begin) whose len is the largest among all palindromes auto pair = make_tuple(0, 0); for(auto center = 0; center \u0026lt; s.size()*2 + 1; center++) { auto len = 0; for(;; len++) { const auto l = center - len - 1; const auto r = center + len; if(l \u0026lt; 0 || r \u0026gt;= s.size()*2 + 1 || s[l/2] != s[r/2]) break; } pair = max(pair, make_tuple(len, (center - len) / 2)); } return s.substr(get\u0026lt;1\u0026gt;(pair), get\u0026lt;0\u0026gt;(pair)); } };  從中央往左右檢查，跳過重複字元的解法：\nclass Solution { public: string longestPalindrome(string s) { // the pair (len, begin) whose len is the largest among all palindromes auto pair = make_tuple(0, 0); for(auto center = 0; center \u0026lt; s.size(); center++) { auto l = center; auto r = center; while(l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() - 1 \u0026amp;\u0026amp; s[l] == s[r + 1]) r++; while(l \u0026gt; 0 \u0026amp;\u0026amp; r \u0026lt; s.size() - 1 \u0026amp;\u0026amp; s[l - 1] == s[r + 1]) l--, r++; pair = max(pair, make_tuple(r - l + 1, l)); } return s.substr(get\u0026lt;1\u0026gt;(pair), get\u0026lt;0\u0026gt;(pair)); } };  Manacher\u0026rsquo;s Algorithm：\nclass Solution { public: string longestPalindrome(string s) { vector\u0026lt;int\u0026gt; rads(s.size() * 2 + 1); auto center = 0; auto right = 0; auto max_beg = 1; auto max_rad = 1; // In fact, we know that the following must be true: // rads[0] = 0, rads[2 * s.size()] = 0 // rads[1] = 1, rads[2 * s.size() - 1] = 1 // // Originally, i = [0, 2 * s.size()] // But due to those known zero values(vector's default values), we only need to calculate i = [1, 2 * s.size() - 1]. // // Also, since rads[1] = 1 and we can return arbitrary string when there are multiple solutions, // we don't need to calculate rads[2 * s.size() - 1], and reduce i to [1, 2 * s.size() - 1). // // Furthermore, for the max_rad computed so far, when index = s.size() * 2 - max_rad, // the largest radius it can acheive is max_rad, which is the same as max_rad, and thus we don't need to compute it. // // So, the range for i is [1, s.size() * 2 - max_rad). // In fact, you can start from i = 2, but some rads[] would be wrong(although it won't affect the largest radius) for (auto i = 1; i \u0026lt; s.size() * 2 - max_rad; i++) { auto rad = (i \u0026lt;= right) ? min(right - i, rads[2 * center - i]) : 0; auto l = (i - rad - 1) / 2; auto r = (i + rad) / 2; if (l == r) rad++, l--, r++; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) rad += 2, l--, r++; if (i + rad \u0026gt; right) { center = i; right = i + rad; } if (rad \u0026gt; max_rad) { max_beg = i - rad; max_rad = rad; } rads[i] = rad; } // for (auto i = 0; i \u0026lt; s.size() * 2 + 1; i++) { // if (i % 2 == 0) // cout \u0026lt;\u0026lt; \u0026quot;# \u0026quot;; // else // cout \u0026lt;\u0026lt; s[i / 2] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; // } // cout \u0026lt;\u0026lt; endl; // for (auto i = 0; i \u0026lt; s.size() * 2 + 1; i++) { // cout \u0026lt;\u0026lt; rads[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; // } // cout \u0026lt;\u0026lt; endl; return s.substr(max_beg / 2, max_rad); } };  後記 這篇寫了三個鐘頭救命，我的功課呢？\n","id":2,"section":"posts","summary":"\u003cp\u003e花了超過一個禮拜的第四篇\u003c/p\u003e\n\u003cp\u003e這題我前後大概嘗試了三、四種解法，也有一些收穫想說可以分享一下\u003c/p\u003e","tags":null,"title":"Longest Palindromic Substring","uri":"https://equalkirby.github.io/2021/03/longest-palindromic-substring/","year":"2021"},{"content":"花了好幾天的第三篇\n我好像很久以前就卡這題，但也一直沒把這題放在心上去解，就這樣拖延了好幾年\u0026hellip;\n題目連結 想法 基本上時間複雜度 $\\mathcal{O}(m+n)$ 的方式可以說是顯而易見， 利用 merge 的方式合併兩個陣列，接著根據長度取出中間的元素傳回就好，非常簡單。\n問題主要出在，怎麼樣讓時間複雜度是 $\\mathcal{O}(log(m+n))$ 呢？ 提到中位數，又要對數的時間複雜度，不難聯想應該這題與二分搜有關係， 在此列上四個參考網址，我認為看完以後應該就可以明白怎麼做到的了， 此文就大致上給個想法方向，跟一些細節的提點就可以了。\n關於二分搜的區間跟延伸 這篇的話，我個人覺得前幾個回復都值得一看。 最佳回答主要琢磨於正確性，底下有個回答有介紹全閉跟左閉右開區間寫法的異同， 並且延伸到譬如找到滿足條件的第一個元素或是最後一個元素之類的， 算是幫助複習二分搜的各種寫法與延伸。\nLeetCode 上最多人給好評的解答 此文即是我主要參考的實作。 評論中有一個 More intuitive thinking process 的回覆也很值得一看，補充了一些原文沒有說明得很清楚的細節。\n首先的問題是，到底要怎麼在兩個已經排序的陣列中找到中位數？ 原文給出，其實把中位數想成以下這樣，就可以比較簡單地解決問題：\n dividing a set into two equal length subsets, that one subset is always greater than the other\n 假設現在只有一個陣列，可以想像成要用一根棍子將陣列分成兩邊(棍子只能放在數字與數字間)。\n如果陣列長度是：\n 奇數：那就讓左邊比右邊多一個元素，中位數就是棍子左邊的數字 偶數：就讓兩邊有一樣多的元素，中位數就是棍子左右兩側的數字取平均  這也是說明為何程式碼中的 half_len 裡面會有 +1 的緣故。\narray: 1 2 3 4 5 stick_place: _ _ _ | _ _ stick_index: 0 1 2 3 4 5  以這個例子來說，陣列裡面有五個數字， 根據上面的規則，我們棍子要放在能讓元素個數是左三右二的狀況。 所有能放棍子的位置(stick_place)已用底線標示出來，並且由左至右編號(stick_index)， 顯然地，棍子擺在3號位置就可以滿足我們的條件。\n 那延伸到兩個陣列的話，其實就是我們要在兩個陣列裡面各找一根棍子， 這兩根棍子要滿足底下的條件：\n  如果兩個陣列的總和長度為：\n 奇數：兩根棍子左側的元素個數要比兩根棍子右側的元素個數多一個元素 偶數：兩根棍子的左右側元素個數要相等    兩根棍子的左側元素，全部要小於等於兩根棍子的右側元素\n 因為兩個陣列都是排序過，所以其實可以看成是兩根棍子各自左邊的元素取較大的那個數，要小於等於兩根棍子各自右邊的元素取較小的那個數    這邊的話，因為原文有例子與數學定義，就不再具體說明。\n 那問題變成要怎麼找兩根棍子的位置呢？\n其實，因為要求棍子左右兩邊的元素個數要相等(或左邊比右邊多一個)。 連帶地，一旦決定一個陣列中棍子的位置以後，就可以確定另一個陣列中棍子要擺哪。\n但，對於較長的陣列並不是每個位置都可以擺棍子的。 譬如說兩個陣列的長度分別為 7 和 1，那麼如果在較長的陣列裡面把棍子擺在最左側， 顯然在較短的陣列裡面，棍子怎麼擺都沒辦法滿足我們上面說的第一個關於長度的條件。\n相對地，較短的陣列裡面每個位置都可以擺棍子， 可以看原文裡面的 ps.2，有簡單說明怎麼證明這件事情。\n 再來，我們就可以在較短的陣列裡面，針對每個可以擺的位置進行二分搜檢查條件是否成立。 至於這邊要怎麼樣檢查邊界條件與進行比較，可以直接參考原文(某些邊界條件會自動隱含其他條件，這部分的推導原文中也有)。\n不過，棍子有可能會因為被擺在最左側或是最右側，導致左側或是右側沒有元素。 但因為原題目有規定 $m+n \\ge 1$，所以兩根棍子的左側必定至少有一個元素，但右側可能沒有任何元素。\n拓展到 kth 的解法 這個解法就是看程式碼會有點不知道在搞甚麼，不過還好內文有舉例跟證明。\n假設現在有兩個陣列 $A, B$，其大小分別為 $5, 3$， 因此我們要取中位數，即是計算第 4 小($k = (5+3) / 2 = 4$)的元素。 做法是去兩個陣列各自檢查其第 2 小($k / 2 = 4 / 2 = 2$)的元素，接著我們有以下兩種 case 討論(zero-based index)：\n  $A[1] \u0026lt; B[1]$\n這表示我們可以捨去 $A$ 的前 $k/2$ 個元素，原因在於，$A[0..k/2], B[0..k/2]$ 至多只有 $k$ 個元素， 當 $B[1]\u0026gt;A[1]$ 的時候，對於 $A[1]$ 來說，最多只有 $A[0..k/2-1], B[0..k/2-1]$ 這些元素比他小， 而這些元素總共有 $k - 2$ 個，表示 $A[1]$ 最好的狀況就是第 $k - 1$ 小的元素\n 之所以說是至多 $k$ 個元素，是因為當 $k/2$ 超過陣列長度的時候，是取最後一個元素來比較大小，因此可能不會有到 $k$ 個元素\n   $A[1] \\ge B[1]$\n這個狀況同理可證，捨去 $B$ 的前 $k/2$ 個元素\n  於是我們就可以把 $k$ 縮小一半，並利用遞迴求解，至於實作和 corner case 可以看 code 理解。 實際上我是在交出二分搜以後，參考了 C++ 執行時間在前段班的解法以後，才發現這種解法比較主流。 查了資料理解正確性的證明以後，我反而比較喜歡這個方法，整體來說其實他比較簡單，而且實作上沒那麼多眉角。\n不用額外分奇偶數的解法 這個其實算是選擇性的資料。\n這篇主要在說，想像在原陣列裡面插入 # 在數字間與前後端，棍子可以擺在數字或是 # 上。 當棍子擺在數字上時，數字會被分成兩個與原數字相同的數字擺在棍子左右兩側，因此就不需要針對奇偶數狀況分開討論。 不過索引的範圍會比原先問題大上兩倍，加上還要計算後才能回去用在原本陣列上，或許不會比較快， 但這種想法說不定在其他問題也用得上，個人建議是可以看一下的。\n時間複雜度 二分搜：顯而易見的 $\\mathcal{O}(log(min(m, n)))$\nkth：顯而易見的 $\\mathcal{O}(log(\\frac{m+n}{2}))$\n空間複雜度 都是顯而易見的 $\\mathcal{O}(1)$\n程式碼 二分搜\nclass Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { const auto m = static_cast\u0026lt;int\u0026gt;(nums1.size()); const auto n = static_cast\u0026lt;int\u0026gt;(nums2.size()); if(m \u0026gt; n) return findMedianSortedArrays(nums2, nums1); // int is sufficient, guaranteed by 0 \u0026lt;= m, n \u0026lt;= 1000 auto first = 0; auto last = m + 1; const auto half_len = (m + n + 1) / 2; while(first \u0026lt; last) { const auto i = first + (last - first) / 2; const auto j = half_len - i; if(i \u0026gt; 0 \u0026amp;\u0026amp; nums1[i - 1] \u0026gt; nums2[j]) { last = i; } else if(i \u0026lt; m \u0026amp;\u0026amp; nums2[j - 1] \u0026gt; nums1[i]) { first = i + 1; } else { const auto l1 = i==0 ? numeric_limits\u0026lt;int\u0026gt;::min() : nums1[i-1]; const auto l2 = j==0 ? numeric_limits\u0026lt;int\u0026gt;::min() : nums2[j-1]; const auto mleft = max(l1, l2); // be careful when m + n = 1 if((m + n) % 2 == 1) return mleft; const auto r1 = i==m ? numeric_limits\u0026lt;int\u0026gt;::max() : nums1[i]; const auto r2 = j==n ? numeric_limits\u0026lt;int\u0026gt;::max() : nums2[j]; const auto rmin = min(r1, r2); return (mleft + rmin) / 2.0; } } return -1; } };  kth\nclass Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { const auto m = nums1.size(); const auto n = nums2.size(); const auto len = m + n; const auto half = (len + 1) / 2; if(len % 2 == 0) return (get_kth(nums1.data(), m, nums2.data(), n, half) + get_kth(nums1.data(), m, nums2.data(), n, half + 1)) / 2.0; else return get_kth(nums1.data(), m, nums2.data(), n, half); } double get_kth(const int* pa, const int m, const int* pb, const int n, int k) { if(m == 0) return pb[k - 1]; else if(n == 0) return pa[k - 1]; else if(k == 1) return min(pa[0], pb[0]); const auto npa = pa + min(k / 2, (int)m) - 1; const auto npb = pb + min(k / 2, (int)n) - 1; if(*npa \u0026lt; *npb) { const auto shrunk_size = npa - pa + 1; return get_kth(npa + 1, m - shrunk_size, pb, n, k - shrunk_size); } else { const auto shrunk_size = npb - pb + 1; return get_kth(pa, m, npb + 1, n - shrunk_size, k - shrunk_size); } } }; ","id":3,"section":"posts","summary":"\u003cp\u003e花了好幾天的第三篇\u003c/p\u003e\n\u003cp\u003e我好像很久以前就卡這題，但也一直沒把這題放在心上去解，就這樣拖延了好幾年\u0026hellip;\u003c/p\u003e","tags":null,"title":"Median of Two Sorted Arrays","uri":"https://equalkirby.github.io/2021/03/median-of-two-sorted-arrays/","year":"2021"},{"content":"刷題第二篇\n題目連結 想法 令輸入的字串為 $Str$，$S_i$ 是從 index $i$ 開始的最長且不重複的子字串\n這樣的話，原先的問題就是求 $max(len(S_0), len(S_1), len(S_2),\\dots, len(S_{len(Str)-1}))$\n假設 $S_i$ 這個子字串就是 $Str[i, j)$，那麼只有可能是兩種情況：\n $j = len(Str)$ $j \\lt len(Str)$ 且 $\\exists k \\in [i, j), Str[k] = Str[j]$\n若否，會與 $S_i $定義矛盾  因此，我們就知道 $S_i$ 怎麼求了：針對每個 $S_i$ 都有個 index 從 $i$ 往後跑一次，檢查到如果有相同的字元就停止，即可得到 $j$\n記錄有沒有相同的字元可以簡單地利用 table，因為題目有說可能出現的字元就是英文、數字和符號，那我就偷懶一點，假設他是 ASCII 囉\n char 是不是 signed 並沒有被規定，更為嚴謹的方式是將其當 index 用之前要先轉到 unsigned\n 但其實再仔細觀察，會發現針對上面說的第二種情況，可以得到：\n$max(len(S_{i+1}), len(S_{i+2}), len(S_{i+3}),\\dots, len(S_k)) \\le len(S_i)$\n要證明也很簡單，上述不等式左側裡面的任一個子字串，其起始 index 皆比 $i$ 大，但右端點(半開區間)都是 index $j$\n因此，其區間必然內嵌於 $[i, j)$ 裡面，長度自然不會超過 $len(S_i)$ (若否，會與 $S_i $定義矛盾)\n那麼，我們就可以跳過 $S_{i+1}, S_{i+2}, S_{i+3},\\dots, S_k$ 的計算，而是直接往下求 $S_{k+1}$\n而且，index $j$ 也不需要往回設定從 $k+1$ 開始，因為上一次的 $S_i$ 保證了 $Str[i, j)$ 裡面沒有重複的字元\n已知 $Str[k] = Str[j]$ 且 $k \\in [i, j)$，$Str[k+1, j]$ 自然不會有重複的字元(不然會矛盾)\n因此，這個問題實際上就可以變成所謂的 sliding window\n利用兩個 pointer 維護子字串的起點 $start$ 與終點 $end$，並確保起點到終點之間是沒有重複的字元\n在過程中持續監視子字串的長度，並且將最大值記錄下來，那就會是答案了\n剩下的問題只剩下怎樣有效率地知道 $k$ 是多少？\n我們可以將前面的 table 從記錄字元出現的有無，變成記錄看到 $end$ 為止，上一次該字元出現的 index\n如果該 index 是大於等於 $start$，那就表示目前檢查的字元與 sliding window 內的字元有所重複\n時間複雜度 可以觀察到 sliding window 有這幾個特性：\n $start \\le end$ $start$ 只會停留或是往右走 $end$ 只會停留或是往右走 任何一次更新，$start$ 和 $end$ 之中一定至少有一個往右走  因此 $start$ 與 $end$ 最多就是各走 n 步，得到 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(1)$\n程式碼 #include\u0026lt;algorithm\u0026gt; class Solution { public: int lengthOfLongestSubstring(string s) { using namespace std; int loc[256]; fill(begin(loc), end(loc), -1); auto start = 0; auto len = 0; for(auto i = 0; i \u0026lt; s.size(); i++) { if(loc[s[i]] \u0026gt;= start) { start = loc[s[i]] + 1; } else { len = max(len, i - start + 1); } loc[s[i]] = i; } return len; } }; ","id":4,"section":"posts","summary":"\u003cp\u003e刷題第二篇\u003c/p\u003e","tags":null,"title":"Longest Substring Without Repeating Characters","uri":"https://equalkirby.github.io/2021/03/longest-substring-without-repeating-characters/","year":"2021"},{"content":"感覺該來開始刷題了\n總之這個是第一篇吧\n題目連結 想法 這題其實蠻簡單的，簡單來說就是用 linked list 進行兩個數字的加法\n預先給的格式其實也已經很貼心的把數字倒序，所以就利用 carry flag 從後面往前加就好\n實作時比較需要注意的幾點：\n 題目有保證兩個傳進來的 pointer 非空，但兩個 linked list 可能不等長 即使兩個 pointer 都跑到 nullptr 了，carry flag還有可能沒跑完 對於第一個要被創出來的 Node 要怎樣寫比較統一  底下的 code 算是盡量比較統一的寫法\n存了一個 dummy node 在 stack 上，實際上要傳回去第一個 node 是 head.next\n實際上我用 seq[] 只是因為我很討厭打一樣的 code 打兩次而已\n因為我沒辦法一次寫過要修修改改，所以有兩個地方出現一樣的 code 我很容易打錯QQ\n時間複雜度 顯而易見的 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(n)$\n程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ #include\u0026lt;algorithm\u0026gt; class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { using namespace std; auto head = ListNode(); auto prev = \u0026amp;head; auto carry = 0; ListNode* seq[] = {l1, l2}; while(any_of(begin(seq), end(seq), [](auto p){return p;}) || carry) { auto sum = carry; for(auto\u0026amp; p : seq) { if(p) { sum += p-\u0026gt;val; p = p-\u0026gt;next; } } carry = sum / 10; auto cur = new ListNode(sum % 10); prev-\u0026gt;next = cur; prev = cur; } return head.next; } }; ","id":5,"section":"posts","summary":"\u003cp\u003e感覺該來開始刷題了\u003cbr\u003e\n總之這個是第一篇吧\u003c/p\u003e","tags":null,"title":"Add Two Numbers","uri":"https://equalkirby.github.io/2021/03/add-two-numbers/","year":"2021"},{"content":"#include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hellow World\u0026quot; \u0026lt;\u0026lt; endl; }  $\\forall x \\in X$\n","id":6,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hellow World\u0026quot; \u0026lt;\u0026lt; endl; }  $\\forall x \\in X$","tags":null,"title":"First Post","uri":"https://equalkirby.github.io/2021/01/first-post/","year":"2021"}],"tags":[]}