{"categories":[{"title":"LeetCode","uri":"https://equalkirby.github.io/categories/leetcode/"}],"posts":[{"content":"刷題第二篇\n題目連結 想法 令輸入的字串為 $Str$，$S_i$ 是從 index $i$ 開始的最長且不重複的子字串\n這樣的話，原先的問題就是求 $max(len(S_0), len(S_1), len(S_2),\\dots, len(S_{len(Str)-1}))$\n假設 $S_i$ 這個子字串就是 $Str[i, j)$，那麼只有可能是兩種情況：\n $j = len(Str)$ $j \\lt len(Str)$ 且 $\\exists k \\in [i, j), Str[k] = Str[j]$\n若否，會與 $S_i $定義矛盾  因此，我們就知道 $S_i$ 怎麼求了：針對每個 $S_i$ 都有個 index 從 $i$ 往後跑一次，檢查到如果有相同的字元就停止，即可得到 $j$\n記錄有沒有相同的字元可以簡單地利用 table，因為題目有說可能出現的字元就是英文、數字和符號，那我就偷懶一點，假設他是 ASCII 囉\n char 是不是 signed 並沒有被規定，更為嚴謹的方式是將其當 index 用之前要先轉到 unsigned\n 但其實再仔細觀察，會發現針對上面說的第二種情況，可以得到：\n$max(len(S_{i+1}), len(S_{i+2}), len(S_{i+3}),\\dots, len(S_k)) \\le len(S_i)$\n要證明也很簡單，上述不等式左側裡面的任一個子字串，其起始 index 皆比 $i$ 大，但右端點(半開區間)都是 index $j$\n因此，其區間必然內嵌於 $[i, j)$ 裡面，長度自然不會超過 $len(S_i)$ (若否，會與 $S_i $定義矛盾)\n那麼，我們就可以跳過 $S_{i+1}, S_{i+2}, S_{i+3},\\dots, S_k$ 的計算，而是直接往下求 $S_{k+1}$\n而且，index $j$ 也不需要往回設定從 $k+1$ 開始，因為上一次的 $S_i$ 保證了 $Str[i, j)$ 裡面沒有重複的字元\n已知 $Str[k] = Str[j]$ 且 $k \\in [i, j)$，$Str[k+1, j]$ 自然不會有重複的字元(不然會矛盾)\n因此，這個問題實際上就可以變成所謂的 sliding window\n利用兩個 pointer 維護子字串的起點 $start$ 與終點 $end$，並確保起點到終點之間是沒有重複的字元\n在過程中持續監視子字串的長度，並且將最大值記錄下來，那就會是答案了\n剩下的問題只剩下怎樣有效率地知道 $k$ 是多少？\n我們可以將前面的 table 從記錄字元出現的有無，變成記錄看到 $end$ 為止，上一次該字元出現的 index\n如果該 index 是大於等於 $start$，那就表示目前檢查的字元與 sliding window 內的字元有所重複\n時間複雜度 可以觀察到 sliding window 有這幾個特性：\n $start \\le end$ $start$ 只會停留或是往右走 $end$ 只會停留或是往右走 任何一次更新，$start$ 和 $end$ 之中一定至少有一個往右走  因此 $start$ 與 $end$ 最多就是各走 n 步，得到 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(1)$\n程式碼 #include\u0026lt;algorithm\u0026gt; class Solution { public: int lengthOfLongestSubstring(string s) { using namespace std; int loc[256]; fill(begin(loc), end(loc), -1); auto start = 0; auto len = 0; for(auto i = 0; i \u0026lt; s.size(); i++) { if(loc[s[i]] \u0026gt;= start) { start = loc[s[i]] + 1; } else { len = max(len, i - start + 1); } loc[s[i]] = i; } return len; } }; ","id":0,"section":"posts","summary":"\u003cp\u003e刷題第二篇\u003c/p\u003e","tags":null,"title":"Longest Substring Without Repeating Characters","uri":"https://equalkirby.github.io/2021/03/longest-substring-without-repeating-characters/","year":"2021"},{"content":"感覺該來開始刷題了\n總之這個是第一篇吧\n題目連結 想法 這題其實蠻簡單的，簡單來說就是用 linked list 進行兩個數字的加法\n預先給的格式其實也已經很貼心的把數字倒序，所以就利用 carry flag 從後面往前加就好\n實作時比較需要注意的幾點：\n 題目有保證兩個傳進來的 pointer 非空，但兩個 linked list 可能不等長 即使兩個 pointer 都跑到 nullptr 了，carry flag還有可能沒跑完 對於第一個要被創出來的 Node 要怎樣寫比較統一  底下的 code 算是盡量比較統一的寫法\n存了一個 dummy node 在 stack 上，實際上要傳回去第一個 node 是 head.next\n實際上我用 seq[] 只是因為我很討厭打一樣的 code 打兩次而已\n因為我沒辦法一次寫過要修修改改，所以有兩個地方出現一樣的 code 我很容易打錯QQ\n時間複雜度 顯而易見的 $\\mathcal{O}(n)$\n空間複雜度 顯而易見的 $\\mathcal{O}(n)$\n程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ #include\u0026lt;algorithm\u0026gt; class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { using namespace std; auto head = ListNode(); auto prev = \u0026amp;head; auto carry = 0; ListNode* seq[] = {l1, l2}; while(any_of(begin(seq), end(seq), [](auto p){return p;}) || carry) { auto sum = carry; for(auto\u0026amp; p : seq) { if(p) { sum += p-\u0026gt;val; p = p-\u0026gt;next; } } carry = sum / 10; auto cur = new ListNode(sum % 10); prev-\u0026gt;next = cur; prev = cur; } return head.next; } }; ","id":1,"section":"posts","summary":"\u003cp\u003e感覺該來開始刷題了\u003cbr\u003e\n總之這個是第一篇吧\u003c/p\u003e","tags":null,"title":"Add Two Numbers","uri":"https://equalkirby.github.io/2021/03/add-two-numbers/","year":"2021"},{"content":"#include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hellow World\u0026quot; \u0026lt;\u0026lt; endl; }  $\\forall x \\in X$\n","id":2,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;Hellow World\u0026quot; \u0026lt;\u0026lt; endl; }  $\\forall x \\in X$","tags":null,"title":"First Post","uri":"https://equalkirby.github.io/2021/01/first-post/","year":"2021"}],"tags":[]}